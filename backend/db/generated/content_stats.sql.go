// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: content_stats.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const getContentStatsByID = `-- name: GetContentStatsByID :one
SELECT 
    content_id,
    views,
    likes,
    duration_sec,
    reading_time,
    reactions,
    comments,
    last_sync_at
FROM content_stats
WHERE content_id = $1
`

type GetContentStatsByIDRow struct {
	ContentID   int64     `json:"content_id"`
	Views       int64     `json:"views"`
	Likes       int64     `json:"likes"`
	DurationSec int32     `json:"duration_sec"`
	ReadingTime int32     `json:"reading_time"`
	Reactions   int64     `json:"reactions"`
	Comments    int64     `json:"comments"`
	LastSyncAt  time.Time `json:"last_sync_at"`
}

func (q *Queries) GetContentStatsByID(ctx context.Context, contentID int64) (GetContentStatsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getContentStatsByID, contentID)
	var i GetContentStatsByIDRow
	err := row.Scan(
		&i.ContentID,
		&i.Views,
		&i.Likes,
		&i.DurationSec,
		&i.ReadingTime,
		&i.Reactions,
		&i.Comments,
		&i.LastSyncAt,
	)
	return i, err
}

const getContentStatsByIDs = `-- name: GetContentStatsByIDs :many
SELECT 
    content_id,
    views,
    likes,
    duration_sec,
    reading_time,
    reactions,
    comments,
    last_sync_at
FROM content_stats
WHERE content_id = ANY($1::bigint[])
`

type GetContentStatsByIDsRow struct {
	ContentID   int64     `json:"content_id"`
	Views       int64     `json:"views"`
	Likes       int64     `json:"likes"`
	DurationSec int32     `json:"duration_sec"`
	ReadingTime int32     `json:"reading_time"`
	Reactions   int64     `json:"reactions"`
	Comments    int64     `json:"comments"`
	LastSyncAt  time.Time `json:"last_sync_at"`
}

func (q *Queries) GetContentStatsByIDs(ctx context.Context, contentIds []int64) ([]GetContentStatsByIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentStatsByIDs, pq.Array(contentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentStatsByIDsRow{}
	for rows.Next() {
		var i GetContentStatsByIDsRow
		if err := rows.Scan(
			&i.ContentID,
			&i.Views,
			&i.Likes,
			&i.DurationSec,
			&i.ReadingTime,
			&i.Reactions,
			&i.Comments,
			&i.LastSyncAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContentStats = `-- name: UpsertContentStats :exec
INSERT INTO content_stats (
    content_id,
    views,
    likes,
    duration_sec,
    reading_time,
    reactions,
    comments,
    last_sync_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    NOW()
)
ON CONFLICT (content_id)
DO UPDATE SET
    views = EXCLUDED.views,
    likes = EXCLUDED.likes,
    duration_sec = EXCLUDED.duration_sec,
    reading_time = EXCLUDED.reading_time,
    reactions = EXCLUDED.reactions,
    comments = EXCLUDED.comments,
    last_sync_at = NOW()
`

type UpsertContentStatsParams struct {
	ContentID   int64 `json:"content_id"`
	Views       int64 `json:"views"`
	Likes       int64 `json:"likes"`
	DurationSec int32 `json:"duration_sec"`
	ReadingTime int32 `json:"reading_time"`
	Reactions   int64 `json:"reactions"`
	Comments    int64 `json:"comments"`
}

func (q *Queries) UpsertContentStats(ctx context.Context, arg UpsertContentStatsParams) error {
	_, err := q.db.ExecContext(ctx, upsertContentStats,
		arg.ContentID,
		arg.Views,
		arg.Likes,
		arg.DurationSec,
		arg.ReadingTime,
		arg.Reactions,
		arg.Comments,
	)
	return err
}
