// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contents.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countContents = `-- name: CountContents :one
SELECT COUNT(*)
FROM contents
WHERE
    is_active = true
    AND ($1::text IS NULL OR title ILIKE '%' || $1::text || '%')
    AND ($2::varchar IS NULL OR content_type = $2::varchar)
`

type CountContentsParams struct {
	Query       sql.NullString `json:"query"`
	ContentType sql.NullString `json:"content_type"`
}

func (q *Queries) CountContents(ctx context.Context, arg CountContentsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContents, arg.Query, arg.ContentType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getContentByID = `-- name: GetContentByID :one
SELECT 
    id,
    provider_id,
    provider_content_id,
    title,
    content_type,
    published_at,
    is_active,
    created_at,
    updated_at
FROM contents
WHERE id = $1
`

func (q *Queries) GetContentByID(ctx context.Context, contentID int64) (Content, error) {
	row := q.db.QueryRowContext(ctx, getContentByID, contentID)
	var i Content
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.ProviderContentID,
		&i.Title,
		&i.ContentType,
		&i.PublishedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getContentsByIDs = `-- name: GetContentsByIDs :many
SELECT 
    id,
    provider_id,
    provider_content_id,
    title,
    content_type,
    published_at,
    is_active,
    created_at,
    updated_at
FROM contents
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetContentsByIDs(ctx context.Context, contentIds []int64) ([]Content, error) {
	rows, err := q.db.QueryContext(ctx, getContentsByIDs, pq.Array(contentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Content{}
	for rows.Next() {
		var i Content
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.ProviderContentID,
			&i.Title,
			&i.ContentType,
			&i.PublishedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContents = `-- name: SearchContents :many
SELECT 
    id,
    provider_id,
    provider_content_id,
    title,
    content_type,
    published_at,
    is_active,
    created_at,
    updated_at
FROM contents
WHERE
    is_active = true
    AND ($1::text IS NULL OR title ILIKE '%' || $1::text || '%')
    AND ($2::varchar IS NULL OR content_type = $2::varchar)
ORDER BY id DESC
LIMIT $4 OFFSET $3
`

type SearchContentsParams struct {
	Query       sql.NullString `json:"query"`
	ContentType sql.NullString `json:"content_type"`
	OffsetCount int32          `json:"offset_count"`
	LimitCount  int32          `json:"limit_count"`
}

func (q *Queries) SearchContents(ctx context.Context, arg SearchContentsParams) ([]Content, error) {
	rows, err := q.db.QueryContext(ctx, searchContents,
		arg.Query,
		arg.ContentType,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Content{}
	for rows.Next() {
		var i Content
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.ProviderContentID,
			&i.Title,
			&i.ContentType,
			&i.PublishedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContent = `-- name: UpsertContent :one
INSERT INTO contents (
    provider_id,
    provider_content_id,
    title,
    content_type,
    published_at,
    is_active,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    NOW()
)
ON CONFLICT (provider_id, provider_content_id)
DO UPDATE SET
    title = EXCLUDED.title,
    content_type = EXCLUDED.content_type,
    published_at = EXCLUDED.published_at,
    is_active = EXCLUDED.is_active,
    updated_at = NOW()
RETURNING id
`

type UpsertContentParams struct {
	ProviderID        int64     `json:"provider_id"`
	ProviderContentID string    `json:"provider_content_id"`
	Title             string    `json:"title"`
	ContentType       string    `json:"content_type"`
	PublishedAt       time.Time `json:"published_at"`
	IsActive          bool      `json:"is_active"`
}

func (q *Queries) UpsertContent(ctx context.Context, arg UpsertContentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertContent,
		arg.ProviderID,
		arg.ProviderContentID,
		arg.Title,
		arg.ContentType,
		arg.PublishedAt,
		arg.IsActive,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
